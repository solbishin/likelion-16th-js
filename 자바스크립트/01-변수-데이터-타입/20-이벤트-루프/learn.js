// --------------------------------------------------------------------------
// 실습: JavaScript 작동 원리 (Event Loop)
// --------------------------------------------------------------------------
// * Call Stack: 함수 실행 중심 (프링글스 통 - 후입선출)
// * Web API: 비동기 작업 대행소 (setTimeout 등)
// * Task Queue: 대기열 (버스 정류장 - 선입선출)
// * Event Loop: 콜 스택과 큐를 연결하는 감시자
// --------------------------------------------------------------------------

const runBtn    = document.querySelector('.run-button'),
      codeBlock = document.querySelector('.code-block')

// --------------------------------------------------------------------------
// 코드 실행 흐름 분석 실습
// --------------------------------------------------------------------------

runBtn.addEventListener('click', () => {
  // 코드 블록 초기화
  codeBlock.innerHTML = ''
  
  // [퀴즈] 아래 함수들의 실행 순서는 어떻게 될까요?
  // bar()
  // foo()
  // baz()
})


// 설명:
// 모든 동기 함수(bar, foo, baz)가 종료되어 콜 스택이 비워지면
// 이벤트 루프가 큐에 대기 중이던 setTimeout의 콜백을 스택으로 가져옵니다.


// --------------------------------------------------------------------------
// 핵심 요약!
// --------------------------------------------------------------------------
// 1. JavaScript 엔진은 한 번에 하나의 일(Call Stack)만 합니다.
// 2. 시간이 걸리는 일(Timer, Ajax 등)은 브라우저(Web API)에 맡깁니다.
// 3. Web API에서 끝난 일은 '큐'에서 자기 차례를 기다립니다.
// 4. 이벤트 루프는 '콜 스택'이 텅 비었을 때만 '큐'의 작업을 스택으로 옮깁니다.
// --------------------------------------------------------------------------

// [생각해보기] 
// 만약 setTimeout의 시간을 0으로 설정하면, '[2]'는 바로 출력될까요?



// --------------------------------------------------------------------------

function log(message) {
  const p = document.createElement('p')
  p.textContent = '>' + message
  codeBlock.appendChild(p)
  console.log(message)
}

function foo() {
  return log('[1] (콜 스택에서 즉시 실행)')
}

function bar() {
  log('bar() 실행 시작')

  // setTimeout은 Web API로 넘겨집니다.
  // 500ms(0.5초) 뒤에 콜백 함수가 '큐'로 들어갑니다.
  setTimeout(() => {
    log('[2] (비동기 콜백: 큐를 거쳐 스택이 비었을 때 실행)')
  }, 500)

  log('bar() 실행 종료')
}

function baz() {
  return log('[3] (콜 스택에서 즉시 실행)')
}