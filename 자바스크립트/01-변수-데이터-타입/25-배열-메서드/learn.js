// --------------------------------------------------------------------------
// 실습: 배열 조작 (Array Manipulation)
// --------------------------------------------------------------------------
// * indexOf() : 손님의 방 번호(인덱스)를 찾는 탐지기
// * push / pop : 호텔 끝방(마지막) 관리
// * unshift / shift : 호텔 입구(처음) 관리
// * splice() : 장부 중간을 수정하는 만능 도구
// * slice() : 원본 보존을 위한 장부 복사본 생성
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
// 손님 위치 파악하기
// --------------------------------------------------------------------------

const guestList = ['지율', '상연', '야무', '범쌤']

// [퀴즈] '야무' 손님은 몇 번 방에 계실까요?


// --------------------------------------------------------------------------
// 입구와 끝방 손님 관리 (Push, Pop, Unshift, Shift)
// --------------------------------------------------------------------------


// 1. 끝방(마지막)에 새로운 손님 모시기
// ['지율', '상연', '야무', '범쌤', '심선생님']

// 2. 입구(첫 번째) 손님 배웅하기
// '지율' 퇴실
// console.log('방금 체크아웃하신 분:', leavingGuest)


// --------------------------------------------------------------------------
// 만능 도구 splice()로 장부 중간 수정하기
// --------------------------------------------------------------------------
// 공식: splice(시작_인덱스, 제거_개수, 추가_할_항목)

const numbers = [1, 2, 5]

// 중간(인덱스 2)에 3, 4를 추가하고 싶다면?
// console.log('장부 중간 수정 결과:', numbers) // [1, 2, 3, 4, 5]

// 특정 구간(인덱스 1부터 3개)의 손님을 배웅하려면?
// [2, 3, 4] 제거
// console.log('남은 장부:', numbers) // [1, 5]


// --------------------------------------------------------------------------
// 안전한 백업 장부 만들기 (slice)
// --------------------------------------------------------------------------

const originalLog = ['데이터1', '데이터2', '데이터3']
let backupLog // 원본과 똑같은 사본 생성

// 사본(배열)에 끝에 '데이터4' 추가

// 사본을 수정해도 원본은 안전합니다. (불변성 유지)
console.log('원본 장부:', originalLog) 
console.log('백업 장부:', backupLog)


// --------------------------------------------------------------------------
// 핵심 요약!
// --------------------------------------------------------------------------
// 1. indexOf는 원시 값(문자, 숫자)을 찾을 때 최적입니다.
// 2. splice는 원본 배열을 직접 수정(Mutable)하므로 주의해서 사용해야 합니다.
// 3. slice는 원본을 건드리지 않고 새로운 배열을 반환(Immutable)합니다.
// 4. 배열의 시작 조작(unshift, shift)은 끝 조작(push, pop)보다 컴퓨터에게 더 힘든 작업입니다.
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
// 린터(Linter) 점검 실습: 아래 코드의 '잠재적 버그'를 예측해보세요.
// --------------------------------------------------------------------------

const fruits = ['사과', '바나나']

// ⚠️ 린터가 'no-unused-vars' 경고를 보낼 수 있습니다.
// const lastFruit = fruits.pop()

// 만약 pop()을 한 번 더 실행한다면, fruits는 어떤 상태가 될까요?